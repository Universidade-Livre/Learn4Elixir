# Learn 4 Elixir - Cap√≠tulo 1

## Introdu√ß√£o

Neste cap√≠tulo iremos apresentar a voc√™, brevemente, a linguagem de programa√ß√£o Elixir. Assim como nos demais cap√≠tulos, voc√™ deve acompanhar este cap√≠tulo no [Livebook](https://livebook.dev/).

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter1.livemd)

## Elixir

Elixir √© uma linguagem criada pelo brasileiro [Jos√© Valim](https://github.com/josevalim). O projeto come√ßou em 2011, enquanto Valim fazia parte da empresa [Plataformatec](https://plataformatec.com/), da qual ele era um dos s√≥cios. Em 24 de maio de 2012 foi lan√ßada a vers√£o 0.5 de Elixir, a primeira vers√£o, segundo Valim, com as caracter√≠sticas de Elixir atual. Por esta raz√£o o [anivers√°rio de 10 anos de Elixir foi comemorado em 24 de maio de 2022](http://adolfont.github.io/service/events/10YearsOfElixir/).

De acordo com sua pr√≥pria defini√ß√£o, o Elixir √© "uma linguagem din√¢mica e funcional, projetada para construir aplica√ß√µes escal√°veis e sustent√°veis". A linguagem foi desenvolvida para ser executada sobre a m√°quina virtual de Erlang (chamada de BEAM), com o objetivo de ampliar a produtividade e extensibilidade do ecossistema da linguagem [Erlang](https://www.erlang.org/), criada na d√©cada de 80. O ecossistema de Erlang refere-se ao conjunto de tecnologias, ferramentas, bibliotecas e comunidades relacionadas a Erlang. Erlang √© uma linguagem de programa√ß√£o funcional, concorrente e tolerante a falhas.

O ecossistema de Erlang √© conhecido por sua for√ßa em sistemas distribu√≠dos e de tempo real flex√≠vel, especialmente em aplica√ß√µes de telecomunica√ß√µes e comunica√ß√µes em larga escala. [WhatsApp √© um exemplo de empresa que usa Erlang em produ√ß√£o](https://www.erlang-solutions.com/blog/20-years-of-open-source-erlang-openerlang-interview-with-anton-lavrik-from-whatsapp/). Erlang oferece recursos para lidar com concorr√™ncia, escalabilidade e resili√™ncia, tornando-a adequada para sistemas altamente dispon√≠veis e que exigem baixa lat√™ncia.

### Caso de Uso de Elixir

Um dos casos mais conhecidos de empresa que usa Elixir em produ√ß√£o como uma de suas principais linguagens √© Discord. Em 2019, a empresa escreveu em seu blog o post ["Usando Rust para escalar Elixir para 11 milh√µes de usu√°rios concorrentes"](https://discord.com/blog/using-rust-to-scale-elixir-for-11-million-concurrent-users). Segundo a equipe de desenvolvedores, a escolha pelo Elixir veio desde o in√≠cio, quando buscavam criar um sistema altamente concorrente em tempo real ‚Äî o prot√≥tipo do Discord foi programado em Elixir.

Outros exemplos de empresas que usam Elixir em produ√ß√£o podem ser encontrados [se√ß√£o Cases da p√°gina da linguagem Elixir](https://elixir-lang.org/cases.html).

*Agora vamos come√ßar a aprender Elixir!*

## O que √© um valor?

Um valor representa um dado do mundo. Por exemplo, 10 pode representar a idade de uma pessoa. Maria o nome desta pessoa e professora sua profiss√£o. O sal√°rio mensal de Maria √© R$ 5.050,55. Clique em _Evaluate_ para avaliar cada um dos valores. O bot√£o _Evaluate_ aparece quando voc√™ passa o _mouse_ em cima do canto superior esquerdo da caixa onde fica o valor. Depois da primeira avalia√ß√£o, o bot√£o se torna _Reevaluate_.

```elixir
10
```

```elixir
"Maria"
```

```elixir
"professora"
```

```elixir
5050.55
```

Quando executamos valores o Elixir nos retorna exatamente esse valor como resultado. Isso acontece porque os valores s√£o constantes e imut√°veis. Quando avaliados, retornam a si mesmos uma vez que nenhuma transforma√ß√£o √© aplicada.

<!-- livebook:{"break_markdown":true} -->

Mas antes de mais nada temos que observar que os dados acima t√™m tipos diferentes.

## Quais s√£o os tipos de valores?

Vamos come√ßar nossa explora√ß√£o pelos tipos de dados fundamentais na programa√ß√£o, que formam a base sobre a qual constru√≠mos a l√≥gica e a estrutura de nossos programas. Os tipos b√°sicos que abordaremos incluem: N√∫meros Inteiros, N√∫meros de Ponto Flutuante, Valores L√≥gicos (Booleanos), √Åtomos e Cadeias de Caracteres (_Strings_).

## N√∫meros Inteiros

Abaixo voc√™ pode  ver e avaliar v√°rios n√∫meros inteiros. N√∫meros inteiros s√£o usados para representar valores n√∫mericos que n√£o precisam de casas decimais.

```elixir
10
```

Observe, no √∫ltimo exemplo, que voc√™ pode usar o "_" como separador.

```elixir
654_677_888_788_899
```

Da mesma forma √© poss√≠vel representar n√∫meros negativos utilizando sinal.

```elixir
-5_323_456_546_346
```

Al√©m disso √© poss√≠vel representar n√∫meros em outras bases como bin√°rio (prefixando com **0b**), octal (prefixando com **0o**) e hexadecimal (prefixando com **0x**).

```elixir
0b101010
```

```elixir
0o52
```

```elixir
0x2A
```

## N√∫meros de Ponto Flutuante

N√∫meros de ponto flutuante exigem um ponto decimal depois de pelo menos um d√≠gito. Eles possuem precis√£o de 64 bits e suportam "e" para n√∫meros exponenciais.

Avalie os exemplos abaixo para ver o que acontece!

```elixir
1.618
```

```elixir
.14
```

```elixir
1.0e-10
```

```elixir
1.234e3
```

> Em qual dos exemplos acima aconteceu um erro? Por qu√™?

## √Åtomos

Em Elixir, um √°tomo √© uma esp√©cie de palavra-chave constante que tem um nome que √© igual ao seu valor. Imagine um √°tomo como uma etiqueta com uma palavra que representa algo espec√≠fico. A coisa interessante sobre os √°tomos em Elixir √© que eles sempre come√ßam com dois pontos (:).

```elixir
:atomo
```

```elixir
:idade
```

```elixir
:peso
```

## Valores L√≥gicos (Booleanos)

Em Elixir, os valores l√≥gicos s√£o como interruptores que podem estar ligados (verdadeiros) ou desligados (falsos). Elixir usa dois √°tomos especiais para representar esses valores: `:true` para verdadeiro e `:false` para falso.

Por√©m esses √°tomos especiais s√£o t√£o importantes e bem conhecidos que voc√™ n√£o precisa colocar dois pontos antes deles como voc√™ faria com outros √°tomos. Em vez disso, voc√™ pode simplesmente usar `true` para representar verdadeiro e `false` para representar falso.

```elixir
is_atom(true)
```

Se voc√™ escrever `true` em Elixir, isso significa "verdadeiro" e representa um valor l√≥gico que est√° ligado ou verdadeiro.

```elixir
true
```

Se voc√™ escrever `false` em Elixir, isso significa "falso" e representa um valor l√≥gico que est√° desligado ou falso.

```elixir
false
```

## Cadeias de Caracteres (Strings)

Uma **cadeia de caracteres**, que √© chamada de **"string"**, √© basicamente uma sequ√™ncia de letras, n√∫meros, s√≠mbolos ou at√© mesmo emojis. Para indicar que algo √© uma string em Elixir, voc√™ a envolve com aspas duplas (`"`). Isso ajuda o Elixir a entender que tudo dentro das aspas √© uma √∫nica string.

```elixir
"Ol√°, Elixir!"
```

As strings em Elixir s√£o inteligentes e podem conter caracteres especiais, como acentos em letras ou at√© mesmo emojis. O Elixir usa a codifica√ß√£o UTF-8, o que significa que √© poss√≠vel representar uma ampla variedade de caracteres de diferentes idiomas e s√≠mbolos.

```elixir
"Jos√© Valim √© o criador de Elixir!! üéâüéâüéâ Ele √© brasileiro!!! üáßüá∑üáßüá∑üáßüá∑"
```

Voc√™ pode at√© mesmo criar strings que se estendem por v√°rias linhas. Para fazer isso, voc√™ usa tr√™s aspas duplas no in√≠cio e no final da string, assim: `"""`.

```elixir
"""
Ol√°, pessoas!
Este √© o Learn4Elixir da Universidade Brasileira Live.
Em Elixir voc√™ pode ter uma string com v√°rias linhas!
"""
```

## Verificando Tipos

Existem diversas fun√ß√µes que nos permitem verificar o tipo de um valor ou express√£o. O mais comum √© quando queremos saber o tipo de um valor usar uma fun√ß√£o **is_** (√â? em ingl√™s) seguida do tipo que queremos saber, como vimos antes **is_atom** checa se o valor √© um √°tomo.

```elixir
is_atom(:um_atomo)
```

Existe uma fun√ß√£o similar para cada tipo, como vamos ver.

```elixir
is_integer(1233)
```

```elixir
is_integer(false)
```

```elixir
is_float(1)
```

```elixir
is_float(1.0)
```

```elixir
is_number(1)
```

```elixir
is_number(1.9)
```

```elixir
is_atom(:peso)
```

```elixir
is_atom(10)
```

```elixir
is_atom(true)
```

```elixir
is_atom(45.4)
```

```elixir
is_boolean(true)
```

```elixir
is_boolean(false)
```

```elixir
is_boolean(0)
```

```elixir
is_boolean(nil)
```

Por√©m, a fun√ß√£o para verificar _strings_ diferente das outras se chama _is_binary_.

```elixir
is_binary("UBL")
```

```elixir
is_binary(true)
```

```elixir
is_binary("üéâüéâüéâ")
```

## Express√µes

Agora que j√° estamos familiarizados com os tipos de dados em Elixir, √© hora de aprender sobre express√µes. Express√µes s√£o maneiras de combinar e manipular esses tipos de dados para realizar tarefas em nosso c√≥digo.

<!-- livebook:{"break_markdown":true} -->

Pense em express√µes como pequenos blocos de constru√ß√£o que nos permitem fazer coisas √∫teis. Por exemplo, podemos usar operadores, que s√£o como ferramentas especiais, para realizar c√°lculos e compara√ß√µes. No entanto, vale ressaltar que os operadores em Elixir s√£o, na verdade, fun√ß√µes especiais que realizam opera√ß√µes espec√≠ficas.

```elixir
2 + 3
```

```elixir
4 - 5
```

```elixir
4 * 80
```

```elixir
4 / 3
```

> Observe que, no exemplo acima, apesar de os operandos serem n√∫meros inteiros, o resultado foi um n√∫mero de ponto flutuante.

<!-- livebook:{"break_markdown":true} -->

Al√©m dos operadores matem√°ticos temos tamb√©m outros operadores. Por exemplo, temos os operadores l√≥gicos que usamos para fazer opera√ß√µes com valores l√≥gicos (booleanos), s√£o eles `and`, `or` e `not`.

<!-- livebook:{"break_markdown":true} -->

`and`: Este operador retorna `true` se **ambos** os operandos forem verdadeiros. Caso contr√°rio, retorna `false`. Por exemplo, `true and false` retornar√° `false`.

```elixir
true and false
```

`or`: Este operador retorna `true` se **qualquer um** dos operandos for verdadeiro. Caso contr√°rio, retorna `false`. Por exemplo, `true or false` retornar√° `true`.

```elixir
false or true
```

`not`: Este √© um operador de nega√ß√£o. Ele inverte o valor do operando. Se o operando for `true`, ele retornar√° `false` e vice-versa. Por exemplo, `not true` retornar√° `false`.

```elixir
not false
```

**Concatena√ß√£o de Strings**: Em Elixir, usamos o operador `<>` para concatenar (ou seja, juntar) duas strings.

```elixir
"UBL" <> " " <> "√© legal!"
```

```elixir
"https://" <> "ulivre.dev"
```

A interpola√ß√£o de strings permite que voc√™ insira valores de vari√°veis ou express√µes dentro de uma string. Em Elixir, usamos `#{}` para interpola√ß√£o de strings.

```elixir
"Onde voc√™ estuda? Eu estudo na #{"UBL"}!"
```

```elixir
"Eu tenho #{25} anos de idade."
```

Observe que n√£o apresentamos nenhuma opera√ß√£o com √°tomos, exceto quando estes s√£o valores l√≥gicos.

## Vari√°veis

Uma vari√°vel √© um nome que representa um valor. Podemos por exemplo atribuir o nome "curso" ao valor string "Matem√°tica".

```elixir
curso = "Matem√°tica"
```

Observe que o retorno da express√£o (toda express√£o em Elixir retorna algo, se n√£o ocporrer nenhum erro) √© o valor que, ap√≥s o casamento de padr√µes, est√° dos dois lados do operador '='.

<!-- livebook:{"break_markdown":true} -->

Agora quando chamarmos o valor "curso" vamos obter seu valor.

```elixir
curso
```

Agora podemos usar esse nome para passar esse valor em qualquer opera√ß√£o com strings.

```elixir
is_binary(curso)
```

```elixir
"Estou estudando #{curso}"
```

Em elixir, todas as vari√°veis s√£o imut√°veis. Isso significa que voc√™ n√£o pode alterar o valor que uma vari√°vel representa, mas voc√™ pode reassociar a vari√°vel a um novo valor.

```elixir
curso = "Ci√™ncia da Computa√ß√£o"
```

Voc√™ n√£o est√° mudando o valor "Matem√°tica" para "Ci√™ncia da Computa√ß√£o", mas sim criando um novo valor "Ci√™ncia da Computa√ß√£o" e fazendo a vari√°vel nome apontar para ele. O valor "Matem√°tica" ainda existe na mem√≥ria, mas n√£o √© mais acess√≠vel pela vari√°vel curso.

## Casamento de Padr√µes (Pattern Matching)

Quando declaramos uma vari√°vel usamos o operador de casamento de padr√µes, cujo s√≠mbolo √© o '=', voc√™ pode casar o padr√£o "UBL", por exemplo, com a vari√°vel 'nome' e assim atribuir "UBL" a 'nome'. Avalie o c√≥digo abaixo:

```elixir
nome = "UBL"
```

Apesar do s√≠mbolo do casamento de padr√µes ser '=', os lados esquerdo e direito de um casamento de padr√µes t√™m "poderes" diferentes. No exemplo acima, vimos como atribuir um valor √† vari√°vel 'nome'. S√≥ pudemos fazer isso porque 'nome' estava no lado esquerdo. Se estivesse no lado direito (ver o exemplo parecido seguinte), n√£o funcionaria. Ou seja, o lado esquerdo "tem mais poder" do que o lado direito.

```elixir
10 = idade
```

Por√©m, uma vez que uma vari√°vel j√° esteja atribu√≠da, √© poss√≠vel us√°-la do lado direito. Veja o exemplo abaixo.

```elixir
"UBL" = nome
```

O exemplo acima √© importante para deixar claro que o casamento de padr√µes n√£o √© uma simples atribui√ß√£o de valor a vari√°vel.

<!-- livebook:{"break_markdown":true} -->

Os demais exemplos de casamento de padr√µes s√≥ fazem sentido se voc√™ conhecer as estrturas de dados compostas (as cole√ß√µes).

## Listas

Cole√ß√µes s√£o estruturas de dados que cont√©m zero ou mais valores. O tipo de cole√ß√£o que provavelmente √© o mais usado em Elixir s√£o as listas. Uma lista pode ser vazia ou conter 1 ou mais elementos. N√£o vamos discutir detalhes de como listas s√£o implementadas em Elixir aqui. Apenas mostraremos como s√£o representadas e como fazer casamento de padr√µes com elas.

```elixir
# Lista Vazia
[]
```

No exemplo acima voc√™ v√™ uma lista vazia e tamb√©m como escrever um coment√°rio de linha em Elixir: tudo que vier depois do '#' √© um coment√°rio.

```elixir
# lista contendo um elemento
[1]
```

```elixir
# lista contendo dois elementos
[3, 45]
```

```elixir
# lista contendo 3 elementos
[45, 78, 21]
```

A partir dos exemplos acima, voc√™ j√° percebeu que as listas come√ßam com '[', terminam com ']' os valores s√£o separados por v√≠rgulas. Mais alguns exemplos.

```elixir
# lista com valores de diferentes tipos.
[1, "Casa", :idade]
```

```elixir
# lista contendo outra lista
[1, [2, 45], 3]
```

Agora vamos ver exemplos de casamento de padr√µes com listas.

```elixir
[cabeca | cauda] = [1, 3, 2]
```

```elixir
cabeca
```

```elixir
cauda
```

```elixir
[primeiro, segundo | resto] = [45, 67, 784, 3453]
```

```elixir
primeiro
```

```elixir
segundo
```

```elixir
resto
```

O exemplo abaixo n√£o d√° erro pois no final de toda lista h√° uma lista vazia.

```elixir
[cabeca | cauda] = [78678]
```

```elixir
cabeca
```

```elixir
cauda
```

Mas o exemplo abaixo d√° erro.

```elixir
[cabeca | cauda] = []
```

No casamento de padr√µes, voc√™ pode usar o operador '_', que alguns chamam de "coringa", para ignorar algo.

```elixir
[cabeca | _] = [646, 345, 345]
```

```elixir
cabeca
```

```elixir
_
```

Nada √© atribu√≠do a '_'.

<!-- livebook:{"break_markdown":true} -->

Veremos depois como utilizar '_' com tuplas.

<!-- livebook:{"break_markdown":true} -->

Uma observa√ß√£o importante, e que est√° relacionada com a forma com que listas s√£o implemantadas, √© que as listas devem crescer na cabe√ßa. Ou seja, se eu for colocar um novo elemento, devo coloc√°-lo como primeiro elemento (mais √† esquerda). Para isso, eu posso usar o operador '|' como nos exemplos abaixo.

```elixir
[1 | [3, 4]]
```

```elixir
[1 | []]
```

```elixir
[2, 3, 4 | [6, 7, 8, 9]]
```

Apenas tenha cuidado para n√£o gerar listas imp√≥prias! Depois do '|' deve vir uma lista.

```elixir
[1 | 2]
```

√â poss√≠vel, mas n√£o recomend√°vel se a segunda lista for grande, concatenar listas. O operador de concatena√ß√£o √© o '++/2'.

```elixir
[1, 3, 56] ++ [34, 560, 8]
```

Uma pequena nota sobre o formato de nome '++/2' usado acima. Em Elixir, o nome de uma fun√ß√£o ou operador tem dois componentes: o nome em si (neste caso ++) e sua aridade. Aridade √© informa√ß√£o essencial quando se fala sobre c√≥digo Elixir. A aridade indica o n√∫mero de argumentos que uma dada fun√ß√£o ou operador aceita (dois, neste nosso exemplo). Nome e aridade s√£o combinados com uma barra.

```elixir
# subtra√ß√£o de listas, operador '--/2'
[1, 2, 3] -- [1, 3]
```

```elixir
[1, 2, 2, 3, 2, 3] -- [1, 2, 3, 2]
```

## Tuplas

Uma tupla √© uma cole√ß√£o ordenada de elementos. Parece um pouco com uma lista, mas seu casamento de padr√µes trabalha com um n√∫mero fixo de elementos, diferente das listas, que permitem o casamento de padr√µes sem que se saiba o n√∫mero exato de seus elementos. As tuplas s√£o definidas usando chaves '{', '}' e seus valores s√£o separados por v√≠rgulas..

```elixir
# tupla vazia
{}
```

```elixir
{1}
```

```elixir
{:nome, "Jo√£o"}
```

```elixir
{:nome, "Maria", :idade, 10}
```

Ap√≥s ver os exemplos acima, vamos ver como fazer casamento de padr√µes com tuplas. Suponha que voc√™ tem uma vai√°vel 'pessoa', como abaixo:

```elixir
pessoa = {:nome, "Maria", :idade, 10}
```

E suponha que eu, sabendo a estrutura da tupla pessoa, queira apenas saber o nome da pessoa. Basta fazer:

```elixir
{:nome, nome, _, _} = pessoa
```

```elixir
nome
```

O mesmo poderia ser feito para idade.

```elixir
{_, _, :idade, idade} = pessoa
```

```elixir
idade
```

Ou para os dois ao mesmo tempo.

```elixir
{:nome, nome, :idade, idade} = pessoa
```

```elixir
{nome, idade}
```

Veja que acima n√≥s constru√≠mos uma tupla a partir dos resultados do casamento de padr√µes.

## Mapas (Maps)

Mapas s√£o cole√ß√µes de pares chave-valor, onde cada chave √© √∫nica e associada a um valor espec√≠fico. Em Elixir, os mapas s√£o delimitados por chaves %{} e podem conter zero ou mais pares chave-valor. Aqui est√° uma representa√ß√£o b√°sica de um mapa em Elixir:

<!-- livebook:{"break_markdown":true} -->



```elixir
%{:chave1 => "valor 1", :chave2 => "valor 2", :chave3 => "valor 3"}
```

As chaves e os valores em um mapa podem ser de qualquer tipo, incluindo √°tomos, n√∫meros, strings e at√© mesmo outras estruturas de dados.

```elixir
%{1 => "algo", 2 => :algo, 3 => [1, 2, 3]}
```

Em Elixir, voc√™ pode criar um mapa simplesmente usando a nota√ß√£o de chaves %{} e especificando os pares chave-valor. Aqui est√£o alguns exemplos:

```elixir
# Um mapa vazio
%{}
```

```elixir
# Um mapa com pares chave-valor
%{nome: "Alice", idade: 30, cidade: "S√£o Paulo"}
```

```elixir
# Um mapa com tipos diferentes de valores
%{nome: "Bob", pontos: 42, aprovado: true}
```

Lembre-se de que as chaves em um mapa s√£o √∫nicas. Se voc√™ tentar adicionar uma chave que j√° existe, o valor anterior ser√° substitu√≠do pelo novo valor.

```elixir
# Isso substituir√° "Alice" por "Bob" na chave "nome"
%{nome: "Alice", nome: "Bob"}
```

Para acessar valores em um mapa, voc√™ usa a sintaxe de colchetes mapa[chave]. Aqui est√£o alguns exemplos:

```elixir
# Criando um mapa
dados = %{nome: "Alice", idade: 30, cidade: "S√£o Paulo"}

# Acessando valores
nome = dados[:nome]
idade = dados[:idade]
cidade = dados[:cidade]
```

```elixir
nome
```

```elixir
idade
```

```elixir
cidade
```

Se a chave n√£o existir no mapa, uma exce√ß√£o ser√° lan√ßada. Para evitar isso, voc√™ pode usar o operador de acesso seguro **Map.get/2** (`Map` √© um espa√ßo de nomes que cont√™m bastante fun√ß√µes para trabalhar com Mapas, entre elas a fun√ß√£o `get` que recebe dois par√¢metros - o mapa e a chave), que retorna um valor padr√£o em vez de lan√ßar uma exce√ß√£o.

```elixir
# Acessando com Map.get/2
Map.get(dados, :nome)
```

Por√©m, caso n√£o exista a chave isso n√£o vai nos lan√ßar uma exce√ß√£o.

```elixir
Map.get(dados, :algo)
```

Tamb√©m possui a vers√£o Map.get/3 que recebe mais um par√¢metro, que √© o valor que √© retornado caso a chave n√£o exista ao inv√©s de `nil`.

```elixir
Map.get(dados, :algo, "valor quando a chave n√£o existe")
```

Mapas em Elixir s√£o imut√°veis, o que significa que n√£o podem ser modificados ap√≥s a cria√ß√£o. No entanto, voc√™ pode criar novos mapas com valores atualizados. O operador `|` √© usado para criar um novo mapa que cont√©m todas as associa√ß√µes do mapa original, juntamente com quaisquer associa√ß√µes adicionais ou atualizadas.

```elixir
# Atualizando o mapa
mapa = Map.put(dados, :idade, 31)
novos_mapa = Map.put(mapa, :profissao, "Engenheira")
```

Tenha em mente que, como os mapas s√£o imut√°veis, o mapa original permanece inalterado ap√≥s cada atualiza√ß√£o. √â comum atribuir o novo mapa a uma nova vari√°vel, como fizemos acima.

```elixir
mapa
```

Para remover uma chave e seu valor associado de um mapa, voc√™ pode usar a fun√ß√£o `Map.delete/2`.

```elixir
mapa_atualizados = Map.delete(dados, :idade)
```

```elixir
mapa_atualizados
```

Novamente, observe que a opera√ß√£o de exclus√£o n√£o modifica o mapa original, mas cria um novo mapa sem a chave removida.

```elixir
dados
```

Para verificar se uma chave espec√≠fica existe em um mapa, voc√™ pode usar a fun√ß√£o `Map.has_key?/2`.

```elixir
Map.has_key?(dados, :idade)
```

Em Elixir, mapas s√£o frequentemente usados como registros leves para representar dados estruturados. Em vez de definir tipos de registro est√°ticos, voc√™ pode criar mapas com chaves espec√≠ficas para representar entidades de dados.

```elixir
# Representando um usu√°rio com mapa
usuario = %{nome: "Alice", idade: 30, cidade: "S√£o Paulo"}

# Representando um produto com mapa
produto = %{nome: "Celular", preco: 799.99, estoque: 50}
```

> Isso oferece flexibilidade, pois voc√™ pode adicionar ou remover campos conforme necess√°rio, sem precisar modificar a estrutura do registro.

<!-- livebook:{"break_markdown":true} -->

O casamento de padr√µes com mapas em Elixir permite que voc√™ desestruture um mapa e associe suas partes a vari√°veis. Isso torna mais f√°cil acessar os valores espec√≠ficos que voc√™ deseja dentro de um mapa. Vamos come√ßar com um exemplo simples:

```elixir
usuario = %{nome: "Bob", idade: 25, cidade: "Porto Alegre"}

# Casando o mapa
%{nome: nome, idade: idade} = usuario
```

Neste exemplo, estamos casando o mapa `usuario` com um padr√£o que consiste em duas chaves: `:nome` e `:idade`. Os valores associados a essas chaves s√£o extra√≠dos e atribu√≠dos √†s vari√°veis `nome` e `idade`. O resultado √© a impress√£o do nome e da idade do usu√°rio.

```elixir
nome
```

```elixir
idade
```

√Äs vezes, voc√™ pode querer casar um mapa, mas n√£o est√° interessado em todos os valores. Nesse caso, voc√™ pode usar o caractere sublinhado `_` para ignorar valores que n√£o s√£o relevantes para sua opera√ß√£o.

```elixir
# criando um mapa/registro de um curso
curso = %{nome: "Ci√™ncia da Computa√ß√£o", duracao: 5, inicio: 2023}

# Casando o mapa, mas ignorando nome
%{nome: _, duracao: duracao, inicio: inicio} = curso

# soma os valores extra√≠dos do mapa/registro
inicio + duracao
```

Voc√™ tamb√©m pode casar partes espec√≠ficas de um mapa sem a necessidade de casar todas as chaves. Isso √© √∫til quando voc√™ deseja acessar um valor em um mapa complexo sem se preocupar com as outras chaves.

```elixir
# Definindo um mapa complexo
pedido = %{cliente: %{nome: "Alice", idade: 30}, produtos: [%{nome: "Celular", preco: 799.99}]}

# Casando partes do mapa
%{cliente: %{nome: nome, idade: idade}} = pedido

# Interpola os valores extra√≠dos
"Nome do Cliente: #{nome}, Idade do Cliente: #{idade}"
```

Neste exemplo, estamos casando apenas a parte do mapa que corresponde √† informa√ß√£o do cliente. Isso nos permite acessar o nome e a idade do cliente, independentemente de outras informa√ß√µes no mapa.

<!-- livebook:{"break_markdown":true} -->

Em Elixir, voc√™ pode casar mapas aninhados, o que significa que voc√™ pode acessar valores dentro de mapas dentro de mapas. Isso √© especialmente √∫til quando voc√™ lida com estruturas de dados complexas.

```elixir
# Definindo um mapa com aninhamento
empresa = %{nome: "Minha Empresa", endereco: %{rua: "Rua Principal", cidade: "S√£o Paulo"}}

# Casando mapas aninhados
%{endereco: %{cidade: cidade}} = empresa
```

Neste exemplo, estamos casando o mapa `empresa` e acessando a cidade dentro do mapa aninhado `endereco`. Isso nos permite obter a cidade da empresa de forma direta.

<!-- livebook:{"break_markdown":true} -->

Podemos construir um novo mapa com as chaves extraidas.

```elixir
%{cidade: cidade}
```

## Estruturas (Structs)

## Exemplos de casamento de padr√µes um pouco mais complexos

```elixir
[_, num, {:nome, name, :ano, year} | _] = [1, 3, {:nome, "pxto", :ano, 1978}, [45, 67]]
```

```elixir
{num, name, year}
```

## Outras cole√ß√µes

Existem outros tipos de cole√ß√µes em Elixir, mas eles est√£o foram do escopo deste documento.

## Exerc√≠cio

Qual? Quais?

## Links

Se voc√™ quiser saber mais, recomendamos abaixo alguns links que podem ser √∫teis:

* [Elixir School](https://elixirschool.com/pt) - Site que cont√©m v√°rias "li√ß√µes" em portugu√™s.
* [Livros e outros recursos de aprendizagem](https://elixir-lang.org/learning.html)
* [Elixir Brasil - Comunidade no Telegram](https://t.me/elixirbr)
* [Elixir em Foco - podcast em portugu√™s](https://www.elixiremfoco.com/)
