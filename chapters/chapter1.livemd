# Learn 4 Elixir - Cap√≠tulo 1

## Introdu√ß√£o

Neste cap√≠tulo iremos apresentar a voc√™, brevemente, a linguagem de programa√ß√£o Elixir. Assim como nos demais cap√≠tulos, voc√™ deve acompanhar este cap√≠tulo no [Livebook](https://livebook.dev/).

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter1.livemd)

## Elixir

Elixir √© uma linguagem criada pelo brasileiro [Jos√© Valim](https://github.com/josevalim). O projeto come√ßou em 2011, enquanto Valim fazia parte da empresa [Plataformatec](https://plataformatec.com/), da qual ele era um dos s√≥cios. Em 24 de maio de 2012 foi lan√ßada a vers√£o 0.5 de Elixir, a primeira vers√£o, segundo Valim, com as caracter√≠sticas de Elixir atual. Por esta raz√£o o [anivers√°rio de 10 anos de Elixir foi comemorado em 24 de maio de 2022](http://adolfont.github.io/service/events/10YearsOfElixir/).

De acordo com sua pr√≥pria defini√ß√£o, o Elixir √© "uma linguagem din√¢mica e funcional, projetada para construir aplica√ß√µes escal√°veis e sustent√°veis". A linguagem foi desenvolvida para ser executada sobre a m√°quina virtual de Erlang (chamada de BEAM), com o objetivo de ampliar a produtividade e extensibilidade do ecossistema da linguagem [Erlang](https://www.erlang.org/), criada na d√©cada de 80. O ecossistema de Erlang refere-se ao conjunto de tecnologias, ferramentas, bibliotecas e comunidades relacionadas a Erlang. Erlang √© uma linguagem de programa√ß√£o funcional, concorrente e tolerante a falhas.

O ecossistema de Erlang √© conhecido por sua for√ßa em sistemas distribu√≠dos e de tempo real flex√≠vel, especialmente em aplica√ß√µes de telecomunica√ß√µes e comunica√ß√µes em larga escala. [WhatsApp √© um exemplo de empresa que usa Erlang em produ√ß√£o](https://www.erlang-solutions.com/blog/20-years-of-open-source-erlang-openerlang-interview-with-anton-lavrik-from-whatsapp/). Erlang oferece recursos para lidar com concorr√™ncia, escalabilidade e resili√™ncia, tornando-a adequada para sistemas altamente dispon√≠veis e que exigem baixa lat√™ncia.

### Caso de Uso de Elixir

Um dos casos mais conhecidos de empresa que usa Elixir em produ√ß√£o como uma de suas principais linguagens √© Discord. Em 2019, a empresa escreveu em seu blog o post ["Usando Rust para escalar Elixir para 11 milh√µes de usu√°rios concorrentes"](https://discord.com/blog/using-rust-to-scale-elixir-for-11-million-concurrent-users). Segundo a equipe de desenvolvedores, a escolha pelo Elixir veio desde o in√≠cio, quando buscavam criar um sistema altamente concorrente em tempo real ‚Äî o prot√≥tipo do Discord foi programado em Elixir.

Outros exemplos de empresas que usam Elixir em produ√ß√£o podem ser encontrados [se√ß√£o Cases da p√°gina da linguagem Elixir](https://elixir-lang.org/cases.html).

*Agora vamos come√ßar a aprender Elixir!*

## O que √© um valor?

Um valor representa um dado do mundo. Por exemplo, 10 pode representar a idade de uma pessoa. Maria o nome desta pessoa e professora sua profiss√£o. O sal√°rio mensal de Maria √© R$ 5.050,55. Clique em _Evaluate_ para avaliar cada um dos valores. O bot√£o _Evaluate_ aparece quando voc√™ passa o _mouse_ em cima do canto superior esquerdo da caixa onde fica o valor. Depois da primeira avalia√ß√£o, o bot√£o se torna _Reevaluate_.

```elixir
10
```

```elixir
"Maria"
```

```elixir
"professora"
```

```elixir
5050.55
```

Quando executamos valores o Elixir nos retorna exatamente esse valor como resultado. Isso acontece porque os valores s√£o constantes e imut√°veis. Quando avaliados, retornam a si mesmos uma vez que nenhuma transforma√ß√£o √© aplicada.

<!-- livebook:{"break_markdown":true} -->

Mas antes de mais nada temos que observar que os dados acima t√™m tipos diferentes.

## Quais s√£o os tipos de valores?

Vamos come√ßar nossa explora√ß√£o pelos tipos de dados fundamentais na programa√ß√£o, que formam a base sobre a qual constru√≠mos a l√≥gica e a estrutura de nossos programas. Os tipos b√°sicos que abordaremos incluem: N√∫meros Inteiros, N√∫meros de Ponto Flutuante, Valores L√≥gicos (Booleanos), √Åtomos e Cadeias de Caracteres (_Strings_).

## N√∫meros Inteiros

Abaixo voc√™ pode  ver e avaliar v√°rios n√∫meros inteiros. N√∫meros inteiros s√£o usados para representar valores n√∫mericos que n√£o precisam de casas decimais.

```elixir
10
```

Observe, no √∫ltimo exemplo, que voc√™ pode usar o "_" como separador.

```elixir
654_677_888_788_899
```

Da mesma forma √© poss√≠vel representar n√∫meros negativos utilizando sinal.

```elixir
-5_323_456_546_346
```

Al√©m disso √© poss√≠vel representar n√∫meros em outras bases como bin√°rio (prefixando com **0b**), octal (prefixando com **0o**) e hexadecimal (prefixando com **0x**).

```elixir
0b101010
```

```elixir
0o52
```

```elixir
0x2A
```

## N√∫meros de Ponto Flutuante

N√∫meros de ponto flutuante exigem um ponto decimal depois de pelo menos um d√≠gito. Eles possuem precis√£o de 64 bits e suportam "e" para n√∫meros exponenciais.

Avalie os exemplos abaixo para ver o que acontece!

```elixir
1.618
```

```elixir
.14
```

```elixir
1.0e-10
```

```elixir
1.234e3
```

> Em qual dos exemplos acima aconteceu um erro? Por qu√™?
> Segundo exemplo, pois n√£o existe um n√∫mero antes do "." no n√∫mero flutuante

## √Åtomos

Em Elixir, um √°tomo √© uma esp√©cie de palavra-chave constante que tem um nome que √© igual ao seu valor. Imagine um √°tomo como uma etiqueta com uma palavra que representa algo espec√≠fico. A coisa interessante sobre os √°tomos em Elixir √© que eles sempre come√ßam com dois pontos (:).

```elixir
:atomo
```

```elixir
:idade
```

```elixir
:peso
```

## Valores L√≥gicos (Booleanos)

Em Elixir, os valores l√≥gicos s√£o como interruptores que podem estar ligados (verdadeiros), desligados (falsos). Elixir usa dois √°tomos especiais para representar esses valores: `:true` para verdadeiro, `:false` para falso. Estes √°tomos especiais s√£o t√£o importantes e bem conhecidos que voc√™ n√£o precisa colocar dois pontos antes deles como voc√™ faria com outros √°tomos. Em vez disso, voc√™ pode simplesmente usar `true` para representar verdadeiro e `false` para representar falso.

```elixir
is_atom(true)
```

Se voc√™ escrever `true` em Elixir, isso significa "verdadeiro" e representa um valor l√≥gico que est√° ligado ou verdadeiro.

```elixir
true
```

Se voc√™ escrever `false` em Elixir, isso significa "falso" e representa um valor l√≥gico que est√° desligado ou falso.

```elixir
false
```

Um √°tomo especial que est√° relacionado a 'true' e 'false' √© 'nil'. Assim como os dois anteriores, voc√™ pode usar ':nil' ou 'nil'. Se voc√™ escrever `nil` em Elixir, isso significa a aus√™ncia de um valor e, em algumas situa√ß√µes, o 'nil' se comporta como o 'false'. Falaremos mais sobre isso quando abordarmos as opera√ß√µes com valores l√≥gicos.

```elixir
nil
```

```elixir
nil
```

## Cadeias de Caracteres (Strings)

Uma **cadeia de caracteres**, que √© chamada de **"string"**, √© basicamente uma sequ√™ncia de letras, n√∫meros, s√≠mbolos ou at√© mesmo emojis. Para indicar que algo √© uma string em Elixir, voc√™ a envolve com aspas duplas (`"`). Isso ajuda o Elixir a entender que tudo dentro das aspas √© uma √∫nica string.

```elixir
"Ol√°, Elixir!"
```

As strings em Elixir s√£o inteligentes e podem conter caracteres especiais, como acentos em letras ou at√© mesmo emojis. O Elixir usa a codifica√ß√£o UTF-8, o que significa que √© poss√≠vel representar uma ampla variedade de caracteres de diferentes idiomas e s√≠mbolos.

```elixir
"Jos√© Valim √© o criador de Elixir!! üéâüéâüéâ Ele √© brasileiro!!! üáßüá∑üáßüá∑üáßüá∑"
```

Voc√™ pode at√© mesmo criar strings que se estendem por v√°rias linhas. Para fazer isso, voc√™ usa tr√™s aspas duplas no in√≠cio e no final da string, assim: `"""`.

```elixir
"""
Ol√°, pessoas!
Este √© o Learn4Elixir da Universidade Brasileira Live.
Em Elixir voc√™ pode ter uma string com v√°rias linhas!
"""
```

## Verificando Tipos

Existem diversas fun√ß√µes que nos permitem verificar o tipo de um valor ou express√£o. O mais comum √© quando queremos saber o tipo de um valor usar uma fun√ß√£o **is_** (√â? em ingl√™s) seguida do tipo que queremos saber, como vimos antes **is_atom** checa se o valor √© um √°tomo.

```elixir
is_atom(:um_atomo)
```

Existe uma fun√ß√£o similar para cada tipo, como vamos ver.

```elixir
is_integer(1233)
```

```elixir
is_integer(false)
```

```elixir
is_float(1)
```

```elixir
is_float(1.0)
```

```elixir
is_number(1)
```

```elixir
is_number(1.9)
```

```elixir
is_atom(:peso)
```

```elixir
is_atom(10)
```

```elixir
is_atom(true)
```

```elixir
is_atom(45.4)
```

```elixir
is_boolean(true)
```

```elixir
is_boolean(false)
```

```elixir
is_boolean(0)
```

```elixir
is_boolean(nil)
```

Por√©m, a fun√ß√£o para verificar _strings_, diferente das outras se chama _is_binary_.

```elixir
is_binary("UBL")
```

```elixir
is_binary(true)
```

```elixir
is_binary("üéâüéâüéâ")
```

## Express√µes

Agora que j√° estamos familiarizados com os tipos de dados em Elixir, √© hora de aprender sobre express√µes. Express√µes s√£o maneiras de combinar e manipular esses tipos de dados para realizar tarefas em nosso c√≥digo.

<!-- livebook:{"break_markdown":true} -->

Pense em express√µes como pequenos blocos de constru√ß√£o que nos permitem fazer coisas √∫teis. Por exemplo, podemos usar operadores, que s√£o como ferramentas especiais, para realizar c√°lculos e compara√ß√µes. No entanto, vale ressaltar que os operadores em Elixir s√£o, na verdade, fun√ß√µes especiais que realizam opera√ß√µes espec√≠ficas.

```elixir
2 + 3
```

```elixir
4 - 5
```

```elixir
4 * 80
```

```elixir
4 / 3
```

> Observe que, no exemplo acima, apesar de os operandos serem n√∫meros inteiros, o resultado foi um n√∫mero de ponto flutuante.

<!-- livebook:{"break_markdown":true} -->

Al√©m dos operadores matem√°ticos temos tamb√©m outros operadores. Por exemplo, temos os operadores l√≥gicos que usamos para fazer opera√ß√µes com valores l√≥gicos (booleanos), s√£o eles `and`, `or` e `not`.

<!-- livebook:{"break_markdown":true} -->

`and`: Este operador retorna `true` se **ambos** operandos forem verdadeiros. Caso contr√°rio, retorna `false`. Por exemplo, `true and false` retornar√° `false`.

```elixir
true and false
```

`or`: Este operador retorna `true` se **qualquer um** dos operandos for verdadeiro. Caso contr√°rio, retorna `false`. Por exemplo, `true or false` retornar√° `true`.

```elixir
false or true
```

`not`: Este √© um operador de nega√ß√£o. Ele inverte o valor do operando. Se o operando for `true`, ele retornar√° `false` e vice-versa. Por exemplo, `not true` retornar√° `false`.

```elixir
not false
```

Note que os operadores acima sempre esperam valores booleanos `true` e `false` como seus primeiros par√¢metros. Passar um valor n√£o booleano como primeiro par√¢metro para esses operadores resulta em uma exce√ß√£o `BadBoolean`, como pode ser testado abaixo:

```elixir
1 and false
```

Voc√™ pode usar valores n√£o l√≥gicos como segundo argumento de 'and' e 'or'. Mas, caso queria utilizar operadores l√≥gicos com valores n√£o booleanos, como um √°tomo ou n√∫meros,  como primeiro argumento, o Elixir fornece os operadores `&&`, `||` e `!`. Esses operadores aceitam valores de qualquer tipo, e apenas os √°tomos `false` e `nil` ser√£o executados como valores false√°veis ('falsy'). Os demais valores s√£o considerados 'truthy'. Ou seja, para estes operadores (e alguns outros), eles se comportam como verdadeiro.

```elixir
1 && true
```

```elixir
1 || true
```

```elixir
!1
```

```elixir
!false
```

```elixir
!nil
```

```elixir
14 || 15
```

```elixir
14 && 29
```

```elixir
14 && nil
```

```elixir
14 && false
```

Em suma, utilize os operadores `and`, `or` e `not` quando suas express√µes esperam valores exclusivamente booleanos, e os operadores `&&`, `||` e `!` quando valores de tipos diferentes podem ser esperados.

## Concatena√ß√£o de Strings

Em Elixir, usamos o operador `<>` para concatenar (ou seja, juntar) duas strings.

```elixir
"UBL" <> " " <> "√© legal!"
```

```elixir
"https://" <> "ulivre.dev"
```

A interpola√ß√£o de strings permite que voc√™ insira valores de vari√°veis ou express√µes dentro de uma string. Em Elixir, usamos `#{}` para interpola√ß√£o de strings.

```elixir
"Onde voc√™ estuda? Eu estudo na #{"UBL"}!"
```

```elixir
"Eu tenho #{25} anos de idade."
```

Observe que n√£o apresentamos nenhuma opera√ß√£o com √°tomos, exceto quando estes s√£o valores l√≥gicos.

## Vari√°veis

Uma vari√°vel √© um nome que representa um valor. Podemos por exemplo atribuir o nome "curso" ao valor string "Matem√°tica".

```elixir
curso = "Matem√°tica"
```

Observe que o retorno da express√£o (toda express√£o em Elixir retorna algo, se n√£o ocorrer nenhum erro) √© o valor que, ap√≥s o casamento de padr√µes, est√° dos dois lados do operador '='.

<!-- livebook:{"break_markdown":true} -->

Agora quando chamarmos o valor "curso" vamos obter seu valor.

```elixir
curso
```

Agora podemos usar esse nome para passar esse valor em qualquer opera√ß√£o com strings.

```elixir
is_binary(curso)
```

```elixir
"Estou estudando #{curso}"
```

Em elixir, todas as vari√°veis s√£o imut√°veis. Isso significa que voc√™ n√£o pode alterar o valor que uma vari√°vel representa, mas √© poss√≠vel reatribuir a vari√°vel a um novo valor.

```elixir
curso = "Ci√™ncia da Computa√ß√£o"
```

Voc√™ n√£o est√° mudando o valor "Matem√°tica" para "Ci√™ncia da Computa√ß√£o", em vez disso criando um novo valor "Ci√™ncia da Computa√ß√£o" e fazendo a vari√°vel *curso* apontar para ele. O valor "Matem√°tica" ainda existe na mem√≥ria, mas n√£o √© mais acess√≠vel pela vari√°vel curso.

## Casamento de Padr√µes (Pattern Matching)

Quando declaramos uma vari√°vel usamos o operador de casamento de padr√µes, cujo s√≠mbolo √© o '=', voc√™ pode casar o padr√£o "UBL", por exemplo, com a vari√°vel 'nome' e assim atribuir "UBL" a 'nome'. Avalie o c√≥digo abaixo:

```elixir
nome = "UBL"
```

Apesar do s√≠mbolo do casamento de padr√µes ser '=', os lados esquerdo e direito de um casamento de padr√µes t√™m "poderes" diferentes. No exemplo acima, vimos como atribuir um valor √† vari√°vel 'nome'. S√≥ pudemos fazer isso porque 'nome' estava no lado esquerdo. Se estivesse no lado direito (ver o exemplo parecido seguinte), n√£o funcionaria. Ou seja, o lado esquerdo "tem mais poder" do que o lado direito.

```elixir
10 = idade
```

Por√©m, uma vez que uma vari√°vel j√° esteja atribu√≠da, √© poss√≠vel us√°-la do lado direito. Veja o exemplo abaixo.

```elixir
"UBL" = nome
```

O exemplo acima √© importante para deixar claro que o casamento de padr√µes n√£o √© uma simples atribui√ß√£o de valor a vari√°vel.

<!-- livebook:{"break_markdown":true} -->

Os demais exemplos de casamento de padr√µes s√≥ fazem sentido se voc√™ conhecer as estruturas de dados compostas (as cole√ß√µes).

## Listas

Cole√ß√µes s√£o estruturas de dados que cont√©m zero ou mais valores. O tipo de cole√ß√£o que provavelmente √© o mais usado em Elixir s√£o as listas. Uma lista pode ser vazia ou conter 1 ou mais elementos. N√£o vamos discutir detalhes de como listas s√£o implementadas em Elixir aqui. Apenas mostraremos como s√£o representadas e como fazer casamento de padr√µes com elas.

```elixir
# Lista Vazia
[]
```

No exemplo acima voc√™ v√™ uma lista vazia e tamb√©m como escrever um coment√°rio de linha em Elixir: tudo que vier depois do '#' √© um coment√°rio.

```elixir
# lista contendo um elemento
[1]
```

```elixir
# lista contendo dois elementos
[3, 45]
```

```elixir
# lista contendo 3 elementos
[45, 78, 21]
```

A partir dos exemplos acima, voc√™ j√° percebeu que as listas come√ßam com '[', terminam com ']' os valores s√£o separados por v√≠rgulas. Mais alguns exemplos.

```elixir
# lista com valores de diferentes tipos.
[1, "Casa", :idade]
```

```elixir
# lista contendo outra lista
[1, [2, 45], 3]
```

Agora vamos ver exemplos de casamento de padr√µes com listas.

```elixir
[cabeca | cauda] = [1, 3, 2]
```

```elixir
cabeca
```

```elixir
cauda
```

```elixir
[primeiro, segundo | resto] = [45, 67, 784, 3453]
```

```elixir
primeiro
```

```elixir
segundo
```

```elixir
resto
```

O exemplo abaixo n√£o d√° erro pois no final de toda lista h√° uma lista vazia.

```elixir
[cabeca | cauda] = [78678]
```

```elixir
cabeca
```

```elixir
cauda
```

Por√©m, o exemplo abaixo resulta em erro.

```elixir
[cabeca | cauda] = []
```

Isso acontece porque n√£o existe nenhum valor para ser associado √† vari√°vel `cabeca`, pois `cabeca`, nesse contexto, representa o primeiro elemento da lista.

No casamento de padr√µes, voc√™ pode usar o operador '_', que alguns chamam de "coringa", para ignorar algo.

```elixir
[cabeca | _] = [646, 345, 345]
```

```elixir
cabeca
```

```elixir
_
```

Nada √© atribu√≠do a '_'.

<!-- livebook:{"break_markdown":true} -->

Veremos depois como utilizar '_' com tuplas.

<!-- livebook:{"break_markdown":true} -->

Uma observa√ß√£o importante, e que est√° relacionada com a forma com que listas s√£o implementadas, √© que as listas devem crescer a partir da cabe√ßa. Ou seja, se eu for colocar um novo elemento, devo coloc√°-lo como primeiro elemento (mais √† esquerda). Para isso, eu posso usar o operador '|' como nos exemplos abaixo.

```elixir
[1 | [3, 4]]
```

```elixir
[1 | []]
```

```elixir
[2, 3, 4 | [6, 7, 8, 9]]
```

Apenas tenha cuidado para n√£o gerar listas impr√≥prias! Depois do '|' deve vir uma lista.

```elixir
[1 | 2]
```

Embora seja uma poss√≠vel, desaconselha-se a concatena√ß√£o de listas usando o operador `++/2` quando a primeira lista for grande.

```elixir
[1, 3, 56] ++ [34, 560, 8]
```

**NOTA**: Em Elixir, o nome de uma fun√ß√£o ou operador tem dois componentes: o nome em si (neste caso ++) e sua aridade. Aridade √© informa√ß√£o essencial quando se fala sobre c√≥digo Elixir, pois esta indica o n√∫mero de argumentos que uma fun√ß√£o ou operador aceita (dois, neste nosso exemplo). Ou seja, uma fun√ß√£o *soma*, que recebe dois argumentos seria representada como `soma/2`, e esta √© uma fun√ß√£o completamente distinta de `soma/3`, por exemplo. Nome e aridade s√£o combinados com uma barra (/).

```elixir
# subtra√ß√£o de listas, operador '--/2'
[1, 2, 3] -- [1, 3]
```

```elixir
[1, 2, 2, 3, 2, 3] -- [1, 2, 3, 2]
```

## Tuplas

Uma tupla √© uma cole√ß√£o ordenada de elementos. Parece um pouco com uma lista, mas seu casamento de padr√µes trabalha com um n√∫mero fixo de elementos, diferente das listas, que permitem o casamento de padr√µes sem que se saiba o n√∫mero exato de seus elementos. As tuplas s√£o definidas usando chaves '{', '}' e seus valores s√£o separados por v√≠rgulas.

```elixir
# tupla vazia
{}
```

```elixir
{1}
```

```elixir
{:nome, "Jo√£o"}
```

```elixir
{:nome, "Maria", :idade, 10}
```

Ap√≥s ver os exemplos acima, vamos ver como fazer casamento de padr√µes com tuplas. Suponha que voc√™ tem uma vari√°vel 'pessoa', como abaixo:

```elixir
pessoa = {:nome, "Maria", :idade, 10}
```

E suponha que eu, sabendo a estrutura da tupla pessoa, queira apenas saber o nome da pessoa. Basta fazer:

```elixir
{:nome, nome, _, _} = pessoa
```

```elixir
nome
```

O mesmo poderia ser feito para idade.

```elixir
{_, _, :idade, idade} = pessoa
```

```elixir
idade
```

Ou para os dois ao mesmo tempo.

```elixir
{:nome, nome, :idade, idade} = pessoa
```

```elixir
{nome, idade}
```

Veja que acima n√≥s constru√≠mos uma tupla a partir dos resultados do casamento de padr√µes.

## Mapas (Maps)

Mapas s√£o cole√ß√µes de pares chave-valor, onde cada chave √© √∫nica e associada a um valor espec√≠fico. Em Elixir, os mapas s√£o delimitados por chaves %{} e podem conter zero ou mais pares chave-valor. Aqui est√° uma representa√ß√£o b√°sica de um mapa em Elixir:

```elixir
%{:chave1 => "valor 1", :chave2 => "valor 2", :chave3 => "valor 3"}
```

As chaves e os valores em um mapa podem ser de qualquer tipo, incluindo √°tomos, n√∫meros, strings e at√© mesmo outras estruturas de dados.

```elixir
%{1 => "algo", 2 => :algo, 3 => [1, 2, 3]}
```

Em Elixir, voc√™ pode criar um mapa simplesmente usando a nota√ß√£o de chaves %{} e especificando os pares chave-valor. Aqui est√£o alguns exemplos:

```elixir
# Um mapa vazio
%{}
```

```elixir
# Um mapa com pares chave-valor
%{nome: "Alice", idade: 30, cidade: "S√£o Paulo"}
```

```elixir
# Um mapa com tipos diferentes de valores
%{nome: "Bob", pontos: 42, aprovado: true}
```

Lembre-se de que as chaves em um mapa s√£o √∫nicas. Se voc√™ tentar adicionar uma chave que j√° existe, o valor anterior ser√° substitu√≠do pelo novo valor.

```elixir
# Isso substituir√° "Alice" por "Bob" na chave "nome"
%{nome: "Alice", nome: "Bob"}
```

Para acessar valores em um mapa, voc√™ usa a sintaxe de colchetes mapa[chave]. Aqui est√£o alguns exemplos:

```elixir
# Criando um mapa
dados = %{nome: "Alice", idade: 30, cidade: "S√£o Paulo"}

# Acessando valores
nome = dados[:nome]
idade = dados[:idade]
cidade = dados[:cidade]
```

```elixir
nome
```

```elixir
idade
```

```elixir
cidade
```

Quando tentamos acessar uma chave que n√£o existe em nosso mapa usando `[]` ser√° retornado `nil` caso o valor dessa chave n√£o exista.

```elixir
valores = %{"uno" => 1, "dos" => 2, "tres" => 3}
```

```elixir
valores["uno"]
```

```elixir
valores["quatro"]
```

Por√©m, quando criamos um mapa em que **todas as chaves s√£o √°tomos** podemos acessar nossos valores tanto usando `[]` passando o valor da chave, quanto usando o operador ponto `.` para acessar a chave que queremos, esse operador tem a vantagem de lan√ßar um erro caso a chave n√£o exista no mapa o que nos ajuda a encontrar erros e problemas mais cedo.

```elixir
chaves_valores = %{:um => 1, :dois => 2, :tres => 3}
```

```elixir
chaves_valores[:um]
```

```elixir
chaves_valores[:quatro]
```

```elixir
chaves_valores.um
```

```elixir
chaves_valores.quatro
```

Caso queira evitar o erro se a chave n√£o existir no mapa, voc√™ pode usar o operador de acesso seguro **Map.get/2** (`Map` √© um espa√ßo de nomes que cont√™m bastante fun√ß√µes para trabalhar com Mapas, entre elas a fun√ß√£o `get` que recebe dois par√¢metros - o mapa e a chave), que retorna um valor padr√£o em vez de lan√ßar uma exce√ß√£o.

```elixir
# Acessando com Map.get/2
Map.get(dados, :nome)
```

Por√©m, caso n√£o exista a chave isso n√£o vai nos lan√ßar uma exce√ß√£o.

```elixir
Map.get(dados, :algo)
```

Tamb√©m possui a vers√£o Map.get/3 que recebe, como terceiro argumento, o valor que deve ser retornado caso a chave n√£o exista.

```elixir
Map.get(dados, :algo, "valor quando a chave n√£o existe")
```

Mapas em Elixir s√£o imut√°veis, o que significa que n√£o podem ser modificados ap√≥s a cria√ß√£o. No entanto, voc√™ pode criar novos mapas com valores atualizados. O operador `|` √© usado para criar um novo mapa que cont√©m todas as associa√ß√µes do mapa original, juntamente com quaisquer associa√ß√µes adicionais ou atualizadas.

```elixir
# Atualizando o mapa
mapa = Map.put(dados, :idade, 31)
novos_mapa = Map.put(mapa, :profissao, "Engenheira")
```

Tenha em mente que, como os mapas s√£o imut√°veis, o mapa original permanece inalterado ap√≥s cada atualiza√ß√£o. √â comum atribuir o novo mapa a uma nova vari√°vel, como fizemos acima.

```elixir
mapa
```

Para remover uma chave e seu valor associado de um mapa, voc√™ pode usar a fun√ß√£o `Map.delete/2`.

```elixir
mapa_atualizados = Map.delete(dados, :idade)
```

```elixir
mapa_atualizados
```

Novamente, observe que a opera√ß√£o de exclus√£o n√£o modifica o mapa original, mas cria um novo mapa sem a chave removida.

```elixir
dados
```

Para verificar se uma chave espec√≠fica existe em um mapa, voc√™ pode usar a fun√ß√£o `Map.has_key?/2`.

```elixir
Map.has_key?(dados, :idade)
```

```elixir
Map.has_key?(dados, :non_existent_key)
```

Em Elixir, mapas s√£o frequentemente usados como registros leves para representar dados estruturados. Em vez de definir tipos de registro est√°ticos, voc√™ pode criar mapas com chaves espec√≠ficas para representar entidades de dados.

```elixir
# Representando um usu√°rio com mapa
usuario = %{nome: "Alice", idade: 30, cidade: "S√£o Paulo"}

# Representando um produto com mapa
produto = %{nome: "Celular", preco: 799.99, estoque: 50}
```

> Isso oferece flexibilidade, pois voc√™ pode adicionar ou remover campos conforme necess√°rio, sem precisar modificar a estrutura do registro.

<!-- livebook:{"break_markdown":true} -->

O casamento de padr√µes com mapas em Elixir permite que voc√™ desestruture um mapa e associe os valores das chaves √† vari√°veis. Isso torna mais f√°cil acessar os valores espec√≠ficos que voc√™ deseja dentro de um mapa. Vamos come√ßar com um exemplo simples:

```elixir
usuario = %{nome: "Bob", idade: 25, cidade: "Porto Alegre"}

# Casando o mapa
%{nome: nome, idade: idade} = usuario
```

Neste exemplo, estamos casando o mapa `usuario` com um padr√£o que consiste em duas chaves: `:nome` e `:idade`. Os valores associados a essas chaves s√£o extra√≠dos e atribu√≠dos √†s vari√°veis `nome` e `idade`. O resultado √© a impress√£o do nome e da idade do usu√°rio.

```elixir
nome
```

```elixir
idade
```

√Äs vezes, voc√™ pode querer casar um mapa, mas n√£o est√° interessado em todos os valores. Nesse caso, voc√™ pode usar o caractere sublinhado `_` para ignorar valores que n√£o s√£o relevantes para sua opera√ß√£o.

```elixir
# criando um mapa/registro de um curso
curso = %{nome: "Ci√™ncia da Computa√ß√£o", duracao: 5, inicio: 2023}

# Casando o mapa, mas ignorando nome
%{nome: _, duracao: duracao, inicio: inicio} = curso

# soma os valores extra√≠dos do mapa/registro
inicio + duracao
```

Voc√™ tamb√©m pode casar partes espec√≠ficas de um mapa sem a necessidade de casar todas as chaves. Isso √© √∫til quando voc√™ deseja acessar um valor em um mapa complexo sem se preocupar com as outras chaves.

```elixir
# Definindo um mapa complexo
pedido = %{cliente: %{nome: "Alice", idade: 30}, produtos: [%{nome: "Celular", preco: 799.99}]}

# Casando partes do mapa
%{cliente: %{nome: nome, idade: idade}} = pedido

# Interpola os valores extra√≠dos
"Nome do Cliente: #{nome}, Idade do Cliente: #{idade}"
```

Neste exemplo, estamos casando apenas a parte do mapa que corresponde √† informa√ß√£o do cliente. Isso nos permite acessar o nome e a idade do cliente, independentemente de outras informa√ß√µes no mapa.

<!-- livebook:{"break_markdown":true} -->

Em Elixir, voc√™ pode casar mapas aninhados, o que significa que voc√™ pode acessar valores dentro de mapas dentro de mapas. Isso √© especialmente √∫til quando voc√™ lida com estruturas de dados complexas.

```elixir
# Definindo um mapa com aninhamento
empresa = %{nome: "Minha Empresa", endereco: %{rua: "Rua Principal", cidade: "S√£o Paulo"}}

# Casando mapas aninhados
%{endereco: %{cidade: cidade}} = empresa
```

Neste exemplo, estamos casando o mapa `empresa` e acessando a cidade dentro do mapa aninhado `endereco`. Isso nos permite obter a cidade da empresa de forma direta.

<!-- livebook:{"break_markdown":true} -->

Podemos construir um novo mapa com as chaves extraidas.

```elixir
%{cidade: cidade}
```

Podemos usar o operador `|` que vimos anteriormente em Listas para atualizar os valores em mapas.

```elixir
evento = %{nome: "Learn4Elixir", mes_inicio: 10, mes_fim: 11, nota: 10}
```

```elixir
novo_evento = %{evento | nota: 1000}
```

```elixir
# atualizando v√°rios valores
novo_evento = %{evento | nome: "GambiConf", mes_inicio: 11}
```

## Estruturas (Structs)

Em Elixir, as estruturas, ou **structs**, s√£o uma maneira de definir e manipular dados com uma estrutura fixa. Enquanto os mapas s√£o flex√≠veis e podem conter qualquer chave, as structs t√™m um conjunto predefinido de campos e um nome associado a elas. As structs s√£o √∫teis para representar entidades de dados com campos espec√≠ficos e fornecem benef√≠cios como valida√ß√£o de presen√ßa das chaves definidas em tempo de compila√ß√£o, sem√¢ntica na defini√ß√£o de um dado e documenta√ß√£o clara.

```elixir
defmodule Usuario do
  defstruct [:nome, :idade, :cidade]
end
```

Neste exemplo, criamos uma struct chamada `Usuario` com tr√™s campos: `nome`, `idade` e `cidade`.

```elixir
%Usuario{}
```

Para criar um valor do tipo estrutura com dados basta pass√°-los como chave e valor, passsando corretamente o nome e chaves v√°lidas em sua defini√ß√£o. Caso uma seja omitida, ela ir√° receber o valor padr√£o.

```elixir
%Usuario{nome: "Camilo", idade: 28}
```

Uma estrutura n√£o ir√° aceitar qualquer chave que n√£o tenha sido declarada em sua declara√ß√£o.

```elixir
%Usuario{qualquer: "coisa"}
```

```elixir
%Usuario{nome: "Camilo", idade: 28, qualquer: "coisa"}
```

√â poss√≠vel definir estruturas que possuem atributos com valores padr√£o. Caso algum desses valores n√£o sejam fornecidos ao criar uma inst√¢ncia da `struct`, o valor padr√£o √© usado ao inv√©s de `nil`.

```elixir
defmodule Pessoa do
  defstruct nome: "", idade: 0, cidade: ""
end
```

Agora quando criarmos um valor da estrutura com valores padr√£o vamos ter uma estrutura que j√° √© criada com os valores iniciais.

```elixir
%Pessoa{}
```

Voc√™ pode acessar os valores de uma estrutura usando o operador "**.**"

```elixir
%Pessoa{nome: "Ana Bastos", cidade: "S√£o Paulo"}.nome
```

Da mesma forma quando salvamos uma estrutura em uma vari√°vel.

```elixir
pessoa = %Pessoa{nome: "Ana Bastos", cidade: "S√£o Paulo"}
```

```elixir
pessoa.cidade
```

Ambas chaves, com e sem valor padr√£o, podem ser misturadas na declara√ß√£o de uma estrutura desde que as chaves sem valor padr√£o venham primeiro, caso contr√°rio isso ir√° causar um erro.

```elixir
defmodule Animal do
  defstruct [:nome, :idade, especie: "", localizacao: ""]
end
```

> Mude a ordem para `[:nome, :idade, especie: "", localizacao: ""]` e execute novamente a c√©lula.

```elixir
%Animal{}
```

Tamb√©m √© possivel usar `@enforce_keys` para garantir que todas as chaves que s√£o especificadas nessa propriedade sejam fornecidas ao criar um valor da estrutura. Se o campo estiver faltando isso vai causar um erro.

```elixir
defmodule Jogador do
  @enforce_keys [:nome, :idade, :cidade]
  defstruct nome: "", idade: 0, cidade: ""
end
```

```elixir
%Jogador{nome: "Caio", idade: 25, cidade: "S√£o Paulo"}
```

> Resolva esse erro passando os campos que s√£o necess√°rios na c√©lula acima.

<!-- livebook:{"break_markdown":true} -->

Podemos retornar uma nova estrutura copiando os valores da antiga e alterando o que √© necess√°rio utilizando o operador `|`

```elixir
# Cria a vari√°vel contendo os valores de uma inst√¢ncia da nossa estrutura
mentor = %Pessoa{nome: "Dickson Melo", idade: 20, cidade: "Natal"}
```

```elixir
mentor_atualizado = %{mentor | idade: mentor.idade + 1}
```

```elixir
# Criando outra vari√°vel com um valor de nossa estrutura
outro_mentor = %Pessoa{nome: "Douglas Tofoli", cidade: "S√£o Paulo"}

# Atualizando v√°rios campos
outro_mentor_atualizado = %{outro_mentor | nome: "Douglas", idade: 23}
```

## Exerc√≠cio

### Exercicio 1

Escreva um exemplo de dado em Elixir para cada tipo apresentado abaixo, colocando-o como par√¢metro no lugar de `""` na respectiva fun√ß√£o. O resultado de todas as fun√ß√µes deve ser `true`.

```elixir
is_number(100)
```

```elixir
is_integer(5)
```

```elixir
is_float(10.50)
```

```elixir
is_binary("Valim arrebenta")
```

```elixir
is_atom(:atomo)
```

```elixir
is_boolean(false)
```

```elixir
is_map(%{campo1: "campo"})
```

```elixir
is_tuple({:campo1, 10})
```

### Exercicio 2

Imagine que v√°rios desenvolvedores de software que trabalham com front-end
publicaram abertamente seus sal√°rios no Twitter. Voc√™ pensou em fazer um programa
que calculasse a m√©dia aritm√©tica de sal√°rios de cada regi√£o a partir do input de 3 sal√°rios dessa regi√£o.

---

| Handle no Twitter | Sal√°rio    |
| ----------------- | ----------- |
| @ocamilodev       | R$ 71255.53 |
| @ocam_l           | R$ 30236.23 |
| @camilotk_        | R$ 5256.12  |

---

Defina vari√°veis para cada sal√°rio, depois, atribua o c√°lculo de m√©dia aritm√©tica √† vari√°vel m√©dia. Por fim, rode a √∫ltima c√©lula com `if` para garantir que a resposta est√° certa.

```elixir
ocamilodev = 71255.53
ocam_l = 30236.23
camilotk = 5256.12
```

```elixir
media = (ocamilodev + ocam_l + camilotk) / 3
```

```elixir
# Checa se a resposta est√° correta
if floor(media) == 35582 do
  "Parab√©ns, voc√™ acertou!"
else
  "Errooooou!"
end
```

### Exercicio 3

Resolva a equa√ß√£o quadr√°tica **x¬≤ - 2x + 1 = 0** calculando seu delta e sua(s) ra√≠z(es).

> Dica: A opera√ß√£o de ra√≠z quadrada √© feita com `:math.sqrt()`, `:math` √© um m√≥dulo do Erlang que cont√™m diversas fun√ß√µes matem√°ticas que podem ser √∫teis na sua jornada.

```elixir
:math.sqrt(0)
```

```elixir
delta = 0
```

```elixir
x = 1
```

### Exercicio 4

Trabalhando com Elixir voc√™ desenvolveu um sistema de E-commerce. Recentemente voc√™ decidiu extrair os coment√°rios e o sistema respondeu te enviando uma lista de mapas com os coment√°rios. Cada mapa possui as propriedades:

* **productId**: Que √© o valor de identifica√ß√£o do produto.
* **id** Que √© o identificador do coment√°rio.
* **name**: Que √© o t√≠tulo do coment√°rio.
* **email**: Que √© o email de quem fez o coment√°rio.
* **body**: Que cont√™m o coment√°rio.

A resposta completa foi:

```elixir
resposta_completa = [
  %{
    "productId" => 1,
    "id" => 1,
    "name" => "id labore ex et quam laborum",
    "email" => "Eliseo@gardner.biz",
    "body" =>
      "laudantium enim quasi est quidem magnam voluptate ipsam eos\ntempora quo necessitatibus\ndolor quam autem quasi\nreiciendis et nam sapiente accusantium"
  },
  %{
    "productId" => 1,
    "id" => 2,
    "name" => "quo vero reiciendis velit similique earum",
    "email" => "Jayne_Kuhic@sydney.com",
    "body" =>
      "est natus enim nihil est dolore omnis voluptatem numquam\net omnis occaecati quod ullam at\nvoluptatem error expedita pariatur\nnihil sint nostrum voluptatem reiciendis et"
  },
  %{
    "productId" => 2,
    "id" => 6,
    "name" => "et fugit eligendi deleniti quidem qui sint nihil autem",
    "email" => "Presley.Mueller@myrl.com",
    "body" =>
      "doloribus at sed quis culpa deserunt consectetur qui praesentium\naccusamus fugiat dicta\nvoluptatem rerum ut voluptate autem\nvoluptatem repellendus aspernatur dolorem in"
  },
  %{
    "productId" => 2,
    "id" => 7,
    "name" => "repellat consequatur praesentium vel minus molestias voluptatum",
    "email" => "Dallas@ole.me",
    "body" =>
      "maiores sed dolores similique labore et inventore et\nquasi temporibus esse sunt id et\neos voluptatem aliquam\naliquid ratione corporis molestiae mollitia quia et magnam dolor"
  },
  %{
    "productId" => 3,
    "id" => 11,
    "name" => "fugit labore quia mollitia quas deserunt nostrum sunt",
    "email" => "Veronica_Goodwin@timmothy.net",
    "body" =>
      "ut dolorum nostrum id quia aut est\nfuga est inventore vel eligendi explicabo quis consectetur\naut occaecati repellat id natus quo est\nut blanditiis quia ut vel ut maiores ea"
  },
  %{
    "productId" => 3,
    "id" => 12,
    "name" => "modi ut eos dolores illum nam dolor",
    "email" => "Oswald.Vandervort@leanne.org",
    "body" =>
      "expedita maiores dignissimos facilis\nipsum est rem est fugit velit sequi\neum odio dolores dolor totam\noccaecati ratione eius rem velit"
  }
]
```

> Lembre-se de executar a c√©lula com o valor de  `resposta_completa` para poder us√°-la.

<!-- livebook:{"break_markdown":true} -->

Com esses dados use **casamento de padr√µes** (pattern matching) para:

<!-- livebook:{"break_markdown":true} -->

1. Extrair o primeiro coment√°rio.

```elixir
[cabeca | _] = resposta_completa

cabeca
```

1. Salvar o nome do segundo coment√°rio em uma vari√°vel `titulo`.

```elixir
[_, comentario | _] = resposta_completa

titulo = comentario["name"]
titulo
```

1. Extrair o coment√°rio de **id** `11` do produto de **productId** `3` e criar um novo mapa que cont√™m todos os valores desse item por√©m mudando o `email` para `contato@foobar.br`.

```elixir
[_, _, _, _, comentario | _] = resposta_completa
novo_mapa = Map.put(comentario, "email", "contato@foobar.br")
novo_mapa
```

1. Extrair o **body** do terceiro coment√°rio.

```elixir
[_, _, comentario | _] = resposta_completa
Map.get(comentario, "body")
```

1. Criar uma nova lista removendo o segundo item.

```elixir
resposta_completa --
  [
    %{
      "productId" => 1,
      "id" => 2,
      "name" => "quo vero reiciendis velit similique earum",
      "email" => "Jayne_Kuhic@sydney.com",
      "body" =>
        "est natus enim nihil est dolore omnis voluptatem numquam\net omnis occaecati quod ullam at\nvoluptatem error expedita pariatur\nnihil sint nostrum voluptatem reiciendis et"
    }
  ]
```

### Exercicio 5

O Departamento de Astrof√≠sica da NASA entrou em contato com voc√™. Eles precisam organizar as informa√ß√µes dos planetas do Sistema Solar para que os sistemas em Elixir que est√£o rodando simula√ß√µes utilizem para processar essas simula√ß√µes.

Voc√™ recebeu uma ficha com as seguintes informa√ß√µes:
| Nome | Superf√≠cie (km¬≤) | Volume (km¬≥) | Massa (kg) | Temperatura M√©dia (¬∫C) | Dist√¢ncia do Sol (km) |
|------|------|--------|-------|-------------------|--------------------------|
| Merc√∫rio | 7,48√ó10^7 | 6,083√ó10^10   | 3,3011√ó10^23  | 166,85 | 57910000    |
| V√™nus    | 4,60√ó10^8 | 92,843√ó10^10  | 4,8685√ó10^24 | 461    | 108200000   |
| Terra    | 5,10√ó10^8 | 1,08321√ó10^12 | 5,9736√ó10^24  | 14     | 149600000   |
| Marte    | 1,44√ó10^8 | 1,6318√ó10^11    | 6,4174√ó10^23  | -63    | 227940000   |
| J√∫piter    | 6,21796√ó10^10 | 1,43128√ó10^15 | 1,8986√ó10^27 | -108 | 778330000  |
| Saturno    | 4,27√ó10^10 | 8,2713√ó10^14 | 5,6846√ó10^26 | -139 | 1429400000 |
| Urano    | 8,1156√ó10^9 | 6,833√ó10^13 | 8,6810√ó10^25 | -220 |  2870990000    |
| Netuno   | 7,6183√ó10^9 | 6,254√ó10^13 | 1,0243√ó10^26 | -223 | 4504000000     |

E com base nesses dados foi pedido que:

<!-- livebook:{"break_markdown":true} -->

1. Crie um modelo de estrutura (struct) que represente o modelo de um planeta baseado nesses dados fornecidos. Ele deve ter valores default e todos os campos s√£o requeridos.

```elixir
defmodule Planeta do
  @enforce_keys [:nome, :superficie, :volume, :massa, :temperatura, :distancia_sol]
  defstruct nome: "Terra",
            superficie: 5.10 * 10 ** 8,
            volume: 1.08321 * 10 ** 12,
            massa: 5.9736 * 10 ** 24,
            temperatura: 14,
            distancia_sol: 149_600_000
end
```

1. Crie uma variavel `mercurio` com as informa√ß√µes deste planeta em uma inst√¢ncia da estrutura que voc√™ criou.

```elixir
mercurio = %Planeta{
  nome: "Merc√∫rio",
  superficie: 7.48 * 10 ** 7,
  volume: 6.083 * 10 ** 10,
  massa: 3.3011 * 10 ** 23,
  temperatura: 166.85,
  distancia_sol: 57_910_000
}
```

1. Crie uma variavel `venus` com as informa√ß√µes deste planeta em uma inst√¢ncia da estrutura que voc√™ criou.

```elixir
venus = %Planeta{
  nome: "V√™nus",
  superficie: 4.60 * 10 ** 8,
  volume: 92.843 * 10 ** 10,
  massa: 4.8685 * 10 ** 24,
  temperatura: 461,
  distancia_sol: 108_200_000
}
```

1. Crie uma variavel `terra` com as informa√ß√µes deste planeta em uma inst√¢ncia da estrutura que voc√™ criou.

```elixir
terra = %Planeta{
  nome: "Terra",
  superficie: 5.10 * 10 ** 8,
  volume: 1.08321 * 10 ** 12,
  massa: 5.9736 * 10 ** 24,
  temperatura: 14,
  distancia_sol: 149_600_000
}
```

1. Crie uma variavel `marte` com as informa√ß√µes deste planeta em uma inst√¢ncia da estrutura que voc√™ criou.

```elixir
marte = %Planeta{
  nome: "Marte",
  superficie: 1.44 * 10 ** 8,
  volume: 1.6318 * 10 ** 11,
  massa: 6.4174 * 10 ** 23,
  temperatura: -63,
  distancia_sol: 227_940_000
}
```

1. Crie uma variavel `jupiter` com as informa√ß√µes deste planeta em uma inst√¢ncia da estrutura que voc√™ criou.

```elixir
jupiter = %Planeta{
  nome: "Jupiter",
  superficie: 6.21796 * 10 ** 10,
  volume: 1.43128 * 10 ** 15,
  massa: 1.8986 * 10 ** 27,
  temperatura: -108,
  distancia_sol: 778_330_000
}
```

1. Crie uma variavel `saturno` com as informa√ß√µes deste planeta em uma inst√¢ncia da estrutura que voc√™ criou.

```elixir
saturno = %Planeta{
  nome: "Saturno",
  superficie: 4.27 * 10 ** 10,
  volume: 8.2713 * 10 ** 14,
  massa: 5.6846 * 10 ** 26,
  temperatura: -139,
  distancia_sol: 1_429_400_000
}
```

1. Crie uma variavel `urano` com as informa√ß√µes deste planeta em uma inst√¢ncia da estrutura que voc√™ criou.

```elixir
urano = %Planeta{
  nome: "Urano",
  superficie: 8.1156 * 10 ** 9,
  volume: 6.833 * 10 ** 13,
  massa: 8.6810 * 10 ** 25,
  temperatura: -220,
  distancia_sol: 2_870_990_000
}
```

1. Crie uma variavel `netuno` com as informa√ß√µes deste planeta em uma inst√¢ncia da estrutura que voc√™ criou.

```elixir
netuno = %Planeta{
  nome: "Netuno",
  superficie: 7.6183 * 10 ** 9,
  volume: 6.254 * 10 ** 13,
  massa: 1.0243 * 10 ** 26,
  temperatura: -223,
  distancia_sol: 4_504_000_000
}
```

1. Crie um mapa para representar o sistema solar, ela deve ter as chaves:

* **:estrela**: String, valor "Sol"
* **:nome**: String, valor "Sistema Solar"
* **:planetas**: Lista de %Planeta (struct/estrutura), uma lista contendo todos os planetas criados.

Salve esse mapa criado em uma vari√°vel `sistema_solar`.

```elixir
sistema_solar = %{
  estrela: "Sol",
  nome: "Sistema Solar",
  planetas: [mercurio, venus, terra, marte, jupiter, saturno, urano, netuno]
}
```

---

Se voc√™ quiser saber mais, recomendamos abaixo alguns links que podem ser √∫teis:

* [Elixir School](https://elixirschool.com/pt) - Site que cont√©m v√°rias "li√ß√µes" em portugu√™s.
* [Livros e outros recursos de aprendizagem](https://elixir-lang.org/learning.html)
* [Elixir Brasil - Comunidade no Telegram](https://t.me/elixirbr)
* [Elixir em Foco - podcast em portugu√™s](https://www.elixiremfoco.com/)
