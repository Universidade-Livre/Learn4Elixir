# Learn 4 Elixir - Cap√≠tulo 1

## Introdu√ß√£o

Neste cap√≠tulo iremos apresentar a voc√™, brevemente, a linguagem de programa√ß√£o Elixir. Assim como nos demais cap√≠tulos, voc√™ deve acompanhar este cap√≠tulo no [Livebook](https://livebook.dev/).

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter1.livemd)

## Elixir

Elixir √© uma linguagem criada pelo brasileiro [Jos√© Valim](https://github.com/josevalim). O projeto come√ßou em 2011, enquanto Valim fazia parte da empresa [Plataformatec](https://plataformatec.com/), da qual ele era um dos s√≥cios. Em 24 de maio de 2012 foi lan√ßada a vers√£o 0.5 de Elixir, a primeira vers√£o, segundo Valim, com as caracter√≠sticas de Elixir atual. Por esta raz√£o o [anivers√°rio de 10 anos de Elixir foi comemorado em 24 de maio de 2022](http://adolfont.github.io/service/events/10YearsOfElixir/).

De acordo com sua pr√≥pria defini√ß√£o, o Elixir √© "uma linguagem din√¢mica e funcional, projetada para construir aplica√ß√µes escal√°veis e sustent√°veis". A linguagem foi desenvolvida para ser executada sobre a m√°quina virtual de Erlang (chamada de BEAM), com o objetivo de ampliar a produtividade e extensibilidade do ecossistema da linguagem [Erlang](https://www.erlang.org/), criada na d√©cada de 80. O ecossistema de Erlang refere-se ao conjunto de tecnologias, ferramentas, bibliotecas e comunidades relacionadas a Erlang. Erlang √© uma linguagem de programa√ß√£o funcional, concorrente e tolerante a falhas.

O ecossistema de Erlang √© conhecido por sua for√ßa em sistemas distribu√≠dos e de tempo real flex√≠vel, especialmente em aplica√ß√µes de telecomunica√ß√µes e comunica√ß√µes em larga escala. [WhatsApp √© um exemplo de empresa que usa Erlang em produ√ß√£o](https://www.erlang-solutions.com/blog/20-years-of-open-source-erlang-openerlang-interview-with-anton-lavrik-from-whatsapp/). Erlang oferece recursos para lidar com concorr√™ncia, escalabilidade e resili√™ncia, tornando-a adequada para sistemas altamente dispon√≠veis e que exigem baixa lat√™ncia.

### Caso de Uso de Elixir

Um dos casos mais conhecidos de empresa que usa Elixir em produ√ß√£o como uma de suas principais linguagens √© Discord. Em 2019, a empresa escreveu em seu blog o post ["Usando Rust para escalar Elixir para 11 milh√µes de usu√°rios concorrentes"](https://discord.com/blog/using-rust-to-scale-elixir-for-11-million-concurrent-users). Segundo a equipe de desenvolvedores, a escolha pelo Elixir veio desde o in√≠cio, quando buscavam criar um sistema altamente concorrente em tempo real ‚Äî o prot√≥tipo do Discord foi programado em Elixir.

Outros exemplos de empresas que usam Elixir em produ√ß√£o podem ser encontrados [se√ß√£o Cases da p√°gina da linguagem Elixir](https://elixir-lang.org/cases.html).

*Agora vamos come√ßar a aprender Elixir!*

## O que √© um valor?

Um valor representa um dado do mundo. Por exemplo, 10 pode representar a idade de uma pessoa. Maria o nome desta pessoa e professora sua profiss√£o. O sal√°rio mensal de Maria √© R$ 5.050,55. Clique em _Evaluate_ para avaliar cada um dos valores. O bot√£o _Evaluate_ aparece quando voc√™ passa o _mouse_ em cima do canto superior esquerdo da caixa onde fica o valor. Depois da primeira avalia√ß√£o, o bot√£o se torna _Reevaluate_.

```elixir
10
```

```elixir
"Maria"
```

```elixir
"professora"
```

```elixir
5050.55
```

Quando executamos valores o Elixir nos retorna exatamente esse valor como resultado. Isso acontece porque os valores s√£o constantes e imut√°veis. Quando avaliados, retornam a si mesmos uma vez que nenhuma transforma√ß√£o √© aplicada.

<!-- livebook:{"break_markdown":true} -->

Mas antes de mais nada temos que observar que os dados acima t√™m tipos diferentes.

## Quais s√£o os tipos de valores?

Vamos come√ßar nossa explora√ß√£o pelos tipos de dados fundamentais na programa√ß√£o, que formam a base sobre a qual constru√≠mos a l√≥gica e a estrutura de nossos programas. Os tipos b√°sicos que abordaremos incluem: N√∫meros Inteiros, N√∫meros de Ponto Flutuante, Valores L√≥gicos (Booleanos), √Åtomos e Cadeias de Caracteres (_Strings_).

## N√∫meros Inteiros

Abaixo voc√™ pode  ver e avaliar v√°rios n√∫meros inteiros. N√∫meros inteiros s√£o usados para representar valores n√∫mericos que n√£o precisam de casas decimais.

```elixir
10
```

Observe, no √∫ltimo exemplo, que voc√™ pode usar o "_" como separador.

```elixir
654_677_888_788_899
```

Da mesma forma √© poss√≠vel representar n√∫meros negativos utilizando sinal.

```elixir
-5_323_456_546_346
```

Al√©m disso √© poss√≠vel representar n√∫meros em outras bases como bin√°rio (prefixando com **0b**), octal (prefixando com **0o**) e hexadecimal (prefixando com **0x**).

```elixir
0b101010
```

```elixir
0o52
```

```elixir
0x2A
```

## N√∫meros de Ponto Flutuante

N√∫meros de ponto flutuante exigem um ponto decimal depois de pelo menos um d√≠gito. Eles possuem precis√£o de 64 bits e suportam "e" para n√∫meros exponenciais.

Avalie os exemplos abaixo para ver o que acontece!

```elixir
1.618
```

```elixir
.14
```

```elixir
1.0e-10
```

```elixir
1.234e3
```

> Em qual dos exemplos acima aconteceu um erro? Por qu√™?

## √Åtomos

Em Elixir, um √°tomo √© uma esp√©cie de palavra-chave constante que tem um nome que √© igual ao seu valor. Imagine um √°tomo como uma etiqueta com uma palavra que representa algo espec√≠fico. A coisa interessante sobre os √°tomos em Elixir √© que eles sempre come√ßam com dois pontos (:).

```elixir
:atomo
```

```elixir
:idade
```

```elixir
:peso
```

## Valores L√≥gicos (Booleanos)

Em Elixir, os valores l√≥gicos s√£o como interruptores que podem estar ligados (verdadeiros) ou desligados (falsos). Elixir usa dois √°tomos especiais para representar esses valores: `:true` para verdadeiro e `:false` para falso.

Por√©m esses √°tomos especiais s√£o t√£o importantes e bem conhecidos que voc√™ n√£o precisa colocar dois pontos antes deles como voc√™ faria com outros √°tomos. Em vez disso, voc√™ pode simplesmente usar `true` para representar verdadeiro e `false` para representar falso.

```elixir
is_atom(true)
```

Se voc√™ escrever `true` em Elixir, isso significa "verdadeiro" e representa um valor l√≥gico que est√° ligado ou verdadeiro.

```elixir
true
```

Se voc√™ escrever `false` em Elixir, isso significa "falso" e representa um valor l√≥gico que est√° desligado ou falso.

```elixir
false
```

## Cadeias de Caracteres (Strings)

Uma **cadeia de caracteres**, que √© chamada de **"string"**, √© basicamente uma sequ√™ncia de letras, n√∫meros, s√≠mbolos ou at√© mesmo emojis. Para indicar que algo √© uma string em Elixir, voc√™ a envolve com aspas duplas (`"`). Isso ajuda o Elixir a entender que tudo dentro das aspas √© uma √∫nica string.

```elixir
"Ol√°, Elixir!"
```

As strings em Elixir s√£o inteligentes e podem conter caracteres especiais, como acentos em letras ou at√© mesmo emojis. O Elixir usa a codifica√ß√£o UTF-8, o que significa que √© poss√≠vel representar uma ampla variedade de caracteres de diferentes idiomas e s√≠mbolos.

```elixir
"Jos√© Valim √© o criador de Elixir!! üéâüéâüéâ Ele √© brasileiro!!! üáßüá∑üáßüá∑üáßüá∑"
```

Voc√™ pode at√© mesmo criar strings que se estendem por v√°rias linhas. Para fazer isso, voc√™ usa tr√™s aspas duplas no in√≠cio e no final da string, assim: `"""`.

```elixir
"""
Ol√°, pessoas!
Este √© o Learn4Elixir da Universidade Brasileira Live.
Em Elixir voc√™ pode ter uma string com v√°rias linhas!
"""
```

## Verificando Tipos

Existem diversas fun√ß√µes que nos permitem verificar o tipo de um valor ou express√£o. O mais comum √© quando queremos saber o tipo de um valor usar uma fun√ß√£o **is_** (√â? em ingl√™s) seguida do tipo que queremos saber, como vimos antes **is_atom** checa se o valor √© um √°tomo.

```elixir
is_atom(:um_atomo)
```

Existe uma fun√ß√£o similar para cada tipo, como vamos ver.

```elixir
is_integer(1233)
```

```elixir
is_integer(false)
```

```elixir
is_float(1)
```

```elixir
is_float(1.0)
```

```elixir
is_number(1)
```

```elixir
is_number(1.9)
```

```elixir
is_atom(:peso)
```

```elixir
is_atom(10)
```

```elixir
is_atom(true)
```

```elixir
is_atom(45.4)
```

```elixir
is_boolean(true)
```

```elixir
is_boolean(false)
```

```elixir
is_boolean(0)
```

```elixir
is_boolean(nil)
```

Por√©m, a fun√ß√£o para verificar _strings_ diferente das outras se chama _is_binary_.

```elixir
is_binary("UBL")
```

```elixir
is_binary(true)
```

```elixir
is_binary("üéâüéâüéâ")
```

## Express√µes

Agora que j√° estamos familiarizados com os tipos de dados em Elixir, √© hora de aprender sobre express√µes. Express√µes s√£o maneiras de combinar e manipular esses tipos de dados para realizar tarefas em nosso c√≥digo.

<!-- livebook:{"break_markdown":true} -->

Pense em express√µes como pequenos blocos de constru√ß√£o que nos permitem fazer coisas √∫teis. Por exemplo, podemos usar operadores, que s√£o como ferramentas especiais, para realizar c√°lculos e compara√ß√µes. No entanto, vale ressaltar que os operadores em Elixir s√£o, na verdade, fun√ß√µes especiais que realizam opera√ß√µes espec√≠ficas.

```elixir
2 + 3
```

```elixir
4 - 5
```

```elixir
4 * 80
```

```elixir
4 / 3
```

> Observe que, no exemplo acima, apesar de os operandos serem n√∫meros inteiros, o resultado foi um n√∫mero de ponto flutuante.

<!-- livebook:{"break_markdown":true} -->

Al√©m dos operadores matem√°ticos temos tamb√©m outros operadores. Por exemplo, temos os operadores l√≥gicos que usamos para fazer opera√ß√µes com valores l√≥gicos (booleanos), s√£o eles `and`, `or` e `not`.

<!-- livebook:{"break_markdown":true} -->

`and`: Este operador retorna `true` se **ambos** os operandos forem verdadeiros. Caso contr√°rio, retorna `false`. Por exemplo, `true and false` retornar√° `false`.

```elixir
true and false
```

`or`: Este operador retorna `true` se **qualquer um** dos operandos for verdadeiro. Caso contr√°rio, retorna `false`. Por exemplo, `true or false` retornar√° `true`.

```elixir
false or true
```

`not`: Este √© um operador de nega√ß√£o. Ele inverte o valor do operando. Se o operando for `true`, ele retornar√° `false` e vice-versa. Por exemplo, `not true` retornar√° `false`.

```elixir
not false
```

**Concatena√ß√£o de Strings**: Em Elixir, usamos o operador `<>` para concatenar (ou seja, juntar) duas strings.

```elixir
"UBL" <> " " <> "√© legal!"
```

```elixir
"https://" <> "ulivre.dev"
```

A interpola√ß√£o de strings permite que voc√™ insira valores de vari√°veis ou express√µes dentro de uma string. Em Elixir, usamos `#{}` para interpola√ß√£o de strings.

```elixir
"Onde voc√™ estuda? Eu estudo na #{"UBL"}!"
```

```elixir
"Eu tenho #{25} anos de idade."
```

Observe que n√£o apresentamos nenhuma opera√ß√£o com √°tomos, exceto quando estes s√£o valores l√≥gicos.

## Casamento de Padr√µes (Pattern Matching)

Ao falar de casamento de padr√µes, precisamos falar de vari√°veis. Uma vari√°vel precisa ter um nome, que geralmente come√ßa com uma letra m√≠n√∫scula (a conven√ß√£o 'camel_case' √© bastante utilizada), e precisa ser atribu√≠da a um valor para poder ser avaliada. Por exemplo, tente avaliar a vari√°vel 'nome' abaixo e vai acontecer o erro "vari√°vel n√ßao definida" (em ingl√™s, "undefined variable").

```elixir
nome
```

Mas se voc√™ usar o operador de casamento de padr√µes, cujo s√≠mbolo √© o '=', voc√™ pode casar o padr√£o "UBL", por exemplo, com a vari√°vel 'nome' e assim atribuir "UBL" a 'nome'. Avalie o c√≥digo abaixo:

```elixir
nome = "UBL"
```

Observe que o retorno da express√£o (toda express√£o em Elixir retorna algo, se n√£o ocporrer nenhum erro) √© o valor que, ap√≥s o casamento de padr√µes, est√° dos dois lados do operador '='.

<!-- livebook:{"break_markdown":true} -->

Se voc√™ agora pedir para avaliar 'nome', o resultado ser√° diferente.

```elixir
nome
```

Apesar do s√≠mbolo do casamento de padr√µes ser '=', os lados esquerdo e direito de um casamento de padr√µes t√™m "poderes" diferentes. No exemplo acima, vimos como atribuir um valor √† vari√°vel 'nome'. S√≥ pudemos fazer isso porque 'nome' estava no lado esquerdo. Se estivesse no lado direito (ver o exemplo parecido seguinte), n√£o funcionaria. Ou seja, o lado esquerdo "tem mais poder" do que o lado direito.

```elixir
10 = idade
```

Por√©m, uma vez que uma vari√°vel j√° esteja atribu√≠da, √© poss√≠vel us√°-la do lado direito. Veja o exemplo abaixo.

```elixir
"UBL" = nome
```

O exemplo acima √© importante para deixar claro que o casamento de padr√µes n√£o √© uma simples atribui√ß√£o de valor a vari√°vel.

<!-- livebook:{"break_markdown":true} -->

Os demais exemplos de casamento de padr√µes s√≥ fazem sentido se voc√™ conhecer as estrturas de dados compostas (as cole√ß√µes).

## Listas

Cole√ß√µes s√£o estruturas de dados que cont√©m zero ou mais valores. O tipo de cole√ß√£o que provavelmente √© o mais usado em Elixir s√£o as listas. Uma lista pode ser vazia ou conter 1 ou mais elementos. N√£o vamos discutir detalhes de como listas s√£o implementadas em Elixir aqui. Apenas mostraremos como s√£o representadas e como fazer casamento de padr√µes com elas.

```elixir
# Lista Vazia
[]
```

No exemplo acima voc√™ v√™ uma lista vazia e tamb√©m como escrever um coment√°rio de linha em Elixir: tudo que vier depois do '#' √© um coment√°rio.

```elixir
# lista contendo um elemento
[1]
```

```elixir
# lista contendo dois elementos
[3, 45]
```

```elixir
# lista contendo 3 elementos
[45, 78, 21]
```

A partir dos exemplos acima, voc√™ j√° percebeu que as listas come√ßam com '[', terminam com ']' os valores s√£o separados por v√≠rgulas. Mais alguns exemplos.

```elixir
# lista com valores de diferentes tipos.
[1, "Casa", :idade]
```

```elixir
# lista contendo outra lista
[1, [2, 45], 3]
```

Agora vamos ver exemplos de casamento de padr√µes com listas.

```elixir
[cabeca | cauda] = [1, 3, 2]
```

```elixir
cabeca
```

```elixir
cauda
```

```elixir
[primeiro, segundo | resto] = [45, 67, 784, 3453]
```

```elixir
primeiro
```

```elixir
segundo
```

```elixir
resto
```

O exemplo abaixo n√£o d√° erro pois no final de toda lista h√° uma lista vazia.

```elixir
[cabeca | cauda] = [78678]
```

```elixir
cabeca
```

```elixir
cauda
```

Mas o exemplo abaixo d√° erro.

```elixir
[cabeca | cauda] = []
```

No casamento de padr√µes, voc√™ pode usar o operador '_', que alguns chamam de "coringa", para ignorar algo.

```elixir
[cabeca | _] = [646, 345, 345]
```

```elixir
cabeca
```

```elixir
_
```

Nada √© atribu√≠do a '_'.

<!-- livebook:{"break_markdown":true} -->

Veremos depois como utilizar '_' com tuplas.

<!-- livebook:{"break_markdown":true} -->

Uma observa√ß√£o importante, e que est√° relacionada com a forma com que listas s√£o implemantadas, √© que as listas devem crescer na cabe√ßa. Ou seja, se eu for colocar um novo elemento, devo coloc√°-lo como primeiro elemento (mais √† esquerda). Para isso, eu posso usar o operador '|' como nos exemplos abaixo.

```elixir
[1 | [3, 4]]
```

```elixir
[1 | []]
```

```elixir
[2, 3, 4 | [6, 7, 8, 9]]
```

Apenas tenha cuidado para n√£o gerar listas imp√≥prias! Depois do '|' deve vir uma lista.

```elixir
[1 | 2]
```

√â poss√≠vel, mas n√£o recomend√°vel se a segunda lista for grande, concatenar listas. O operador de concatena√ß√£o √© o '++/2'.

```elixir
[1, 3, 56] ++ [34, 560, 8]
```

Uma pequena nota sobre o formato de nome '++/2' usado acima. Em Elixir, o nome de uma fun√ß√£o ou operador tem dois componentes: o nome em si (neste caso ++) e sua aridade. Aridade √© informa√ß√£o essencial quando se fala sobre c√≥digo Elixir. A aridade indica o n√∫mero de argumentos que uma dada fun√ß√£o ou operador aceita (dois, neste nosso exemplo). Nome e aridade s√£o combinados com uma barra.

```elixir
# subtra√ß√£o de listas, operador '--/2'
[1, 2, 3] -- [1, 3]
```

```elixir
[1, 2, 2, 3, 2, 3] -- [1, 2, 3, 2]
```

## Tuplas

Uma tupla √© uma cole√ß√£o ordenada de elementos. Parece um pouco com uma lista, mas seu casamento de padr√µes trabalha com um n√∫mero fixo de elementos, diferente das listas, que permitem o casamento de padr√µes sem que se saiba o n√∫mero exato de seus elementos. As tuplas s√£o definidas usando chaves '{', '}' e seus valores s√£o separados por v√≠rgulas..

```elixir
# tupla vazia
{}
```

```elixir
{1}
```

```elixir
{:nome, "Jo√£o"}
```

```elixir
{:nome, "Maria", :idade, 10}
```

Ap√≥s ver os exemplos acima, vamos ver como fazer casamento de padr√µes com tuplas. Suponha que voc√™ tem uma vai√°vel 'pessoa', como abaixo:

```elixir
pessoa = {:nome, "Maria", :idade, 10}
```

E suponha que eu, sabendo a estrutura da tupla pessoa, queira apenas saber o nome da pessoa. Basta fazer:

```elixir
{:nome, nome, _, _} = pessoa
```

```elixir
nome
```

O mesmo poderia ser feito para idade.

```elixir
{_, _, :idade, idade} = pessoa
```

```elixir
idade
```

Ou para os dois ao mesmo tempo.

```elixir
{:nome, nome, :idade, idade} = pessoa
```

```elixir
{nome, idade}
```

Veja que acima n√≥s constru√≠mos uma tupla a partir dos resultados do casamento de padr√µes.

## Exemplos de casamento de padr√µes um pouco mais complexos

```elixir
[_, num, {:nome, name, :ano, year} | _] = [1, 3, {:nome, "pxto", :ano, 1978}, [45, 67]]
```

```elixir
{num, name, year}
```

## Outras cole√ß√µes

Existem outros tipos de cole√ß√µes em Elixir, mas eles est√£o foram do escopo deste documento.

## Exerc√≠cio

Qual? Quais?

## Links

Se voc√™ quiser saber mais, recomendamos abaixo alguns links que podem ser √∫teis:

* [Elixir School](https://elixirschool.com/pt) - Site que cont√©m v√°rias "li√ß√µes" em portugu√™s.
* [Livros e outros recursos de aprendizagem](https://elixir-lang.org/learning.html)
* [Elixir Brasil - Comunidade no Telegram](https://t.me/elixirbr)
* [Elixir em Foco - podcast em portugu√™s](https://www.elixiremfoco.com/)
